An Informal Analysis of The Secrecy of AES

I do not have the mathematical chops to analyze the math behind AES, nor do I 
have the time to write and run programs to execute 100,000,000 iterations for
analysis. Instead, I will try to answer several questions relevant to patterns 
within the ciphertext of AES, and hope that my probing is consistent with more
general patterns in the algorithm.

==========    General Secrecy    ==========

Using the values for a baseline:
	Key = 32309AFFBC6492FACEE209943FF11BDD12A5C0BE16844305960C33490198DBAF
	Plaintext = 42309AFFBC6492FACEE209943FF11BDC

Getting the output: 9C177D02B99C05D60F8B2793C52DB5F1

63 bits had been changed. So perfect secrecy is out the window right off the
bat. But is AES a reasonable approximation for perfect secrecy?

The distribution of bits changed by byte, shown below, was roughly even, but 
not perfectly so.

5 =====
4 ====
5 =====
6 ======
2 ==
4 ====
4 ====
3 ===
2 ==
4 ====
4 ====
3 ===
5 =====
4 ====
4 ====
4 ====
Total: [63]

Performing this a couple more times with different random keys and plaintexts
yielded similar results. Around 60 bits were changed, and the distribution was
roughly even.

Now using the original key/plaintext pair, I started changing some things.

Changing a single bit of the key and compared the ciphertexts. Only 55 of the 
bits were different, and the differences were distributed uniformly.

This did not change when I moved the changed bit to a more significant position
within a single byte, or in the entire string of bytes. 

I tried larger changes to portions of the key, and oddly enough this caused the
original ciphertext to differ less from the changed ciphertext. The differences 
dipped down into the mid 50s. However, positioning of these larger chunks in 
more or less significant areas in the byte string did not change either the
number of differences, or their distribution.

Both when comparing plaintexts and ciphertexts as well as different ciphertexts 
I noticed that most of the bytes had between 3 and 6 bits which were different
from their counterpart. 2, 7, and 8 bits of difference occurred occassionally, 
and I have yet to see a byte with either one or zero of its bits changed. This 
looks good for the security of AES, since this is what one would expect if each
bit had an equal probability of being changed. Numbers in the middle of the 
range will have a greater probability of being summed to, which is what I see
here.


========== Uniformity of The Key ==========
Do patterns within the key affect secrecy? For instance if the ciphertext does
not have a length not divisible by 128, it gets padded with zeros.

Not really. When I used a random 32 byte key above to encrypt a string of all 
0s, and then compared it to strings with large amounts of padding, the result
was much the same as above. The two ciphertexts had about 50-60 bits of 
difference distributed mostly evenly across the ciphertext. This is to be
expected with a long key (more rounds) since the ShiftRows and MixColumns steps
are executed more times.

I got similar results when using a smaller key (which doesn't really decrease 
the diffusion by that much -- only 4 rounds).


== Similarity of The Key To The Plaintext ==
Using plaintext and key pairs with high similarity did not prove very effective
at producing patterns either. 

Theoretically, if you used the same plaintext and key, you could force the 
algorithm to crack, since subBytes and shiftRows only cause diffusion, and
subBytes would substitute everything to the same value. The trick that gets
in the way with this is the AddRoundKey step.

For example using plaintext and ciphertext EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE
causes the first round to look like:

add round key:	00000000000000000000000000000000
subBytes:	63636363636363636363636363636363
shiftRows:	63636363636363636363636363636363
mixColumns:	63636363636363636363636363636363

In that way, the key expansion sort of protects you if you use a bad key. 
Even if you choose something bad like all Es, that doesn't really show up in 
the ciphertext because the The key expansion (specifically the use of the 
round constant) makes it so that a bad key will eventually become random 
looking by the end of the expansion. 

I wonder if it is possible to provide an initial key such that the final
output of the key expansion is uniform in some way. It would probably
be easier than in the actual cipher itself (since the process for key expansion
isn't mixed up by mixing in the key and plaintext).

I suppose that's the whole point, really. The key is the linchpin which holds
the whole thing together, and provides the actual security, all the other 
transformations just mix things up and make it hard to find things about the
key and plaintext from the ciphertext. In other words, they provide the 
secrecy.

In summary, AES has a pretty good approximation of perfect secrecy. Although 
the tests which I performed were very small in scope, I was not able to find 
any patterns when I changed things around in the key and plaintext. Checking
different cases of encryption with identical keys and plaintexts did not gave 
the same results that everything else did.



